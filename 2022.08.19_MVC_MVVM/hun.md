### 날짜: 2023-08-18 19:50

### 주제:  나는 왜 클린 아키텍처를 공부해야 하는가!
---
### 메모: 
> 빨리 가는 유일한 방법은 제대로 가는 것이다. - Robert C. Martin
#### 나는 왜 클린 아키텍처를 공부해야 하는가
- iOS 개발자로 취업을 준비하면서, 신입 개발자를 뽑는 자리에서 필수사항 또는 우대사항에 MVVM 패턴 또는 RxSwift를 활용할 수 있는 사람을 구하는 것을 심심찮게 확인할 수 있다. 
- 처음 ios개발자가 되고자 했던 나로썬 그러한 공고문만 확인하고 단순하게 기업들이 왜 저런 기술과 디자인 패턴을 주로 활용하는지에 대한 의문은 해결하지 않은체 기술 스택의 사용법을 익히기에 급급했다. 
	- (왜 사용해야 하는가에 대한 내용은 단지 구글링 및 강의를 통해서만 터득) 
- 결국 나는 RxSwift에 대한 기술은 어느정도 이해 했지만, 그 기술을 사용하지 못했다. 마치 영어 단어를 해석할 수는 있지만 그 단어로 문장을 만들지 못하는 것 과 같은 느낌이였다. 
- 그래서  클린 아키텍처를 자세히 알아보고자 로버트 마틴의 Clean Architecture를 정독하게 되었고 어느정도 이해한 내 생각과 책의 내용을 정리하고자 한다. 
	- (책, 이론서를 정독하는 것도 중요하지만 궁극적으로 책의 내용을 나의 코드에 적용할 수 있는 점을 찾아내서, 코드를 좀 더 효율적으로 작성해 작가의 의도를 코드에 녹여내는것이 중요하다고 생각한다.)
#### 아키텍처를 설명하기 앞서
- 작가는 말했다. 
	- 수많은 앱을 만들었고 수많은 시스템을 구축하고 구축한 시스템들이 근본적으로 정말 다르지만 **아키텍처 규칙은 동일**하다고 이에따라 *소프트웨어 아키텍처의 규칙은 다른 모든 변수에 독립적* 이라는 결론을 내렸다. 
	- 언어는 조금 발전했다. 도구는 환상적으로 좋아졌다. 하지만 자세히 보면 컴퓨터 프로그래밍을 이루는 기본 구성요소는 조금도 바뀌지 않았다. 
		- (60년대나 지금이나 코드는 순차(sequence), 분기(selection), 반복(iteration)의 집합체일 뿐이다.)
	- *이것이 열쇠다.* 이처럼 코드가 변하지 않았다는 사실이 시스템의 종류와 관계없이 소프트웨어 아키텍처의 규칙이 일관된 이유다. 그러므로 결국 변한 것이 없다. 
		- *소프트웨어 아키텍처의 규칙:  프로그램의 구성요소를 정렬하고 조립하는 방법에 관한 규칙*
	- 하지만 바뀐 게 딱 하나 있다. 그것은 그 시절의 우리는 이 규칙이 무엇인지를 알지 못했다는 것이다. 결과적으로 우리는 이 규칙을 어겼고, 또 어겼고, 계속해서 어겼다. 
- 나는 처음 MVC패턴으로 앱을 개발하고 공부할 때 (내가 쓰는 패턴이 MVC인지도 인지도 못 하던 시절) 공부하다 강의에서 갑자기 MVP, MVVM 패턴에 대해 설명하고 사용법을 알려주웠을 때 새로운 언어를 배우는 것 과 같은 두려움이 생겼었다. 
-  또한 실제로 강의 내용대로 혼자서 앱도 설계하지 못했다. 또 계속 공부를 하다보니 Combine, RxSwift, VIP, VIPER, TCA등 에 대해 듣게 되었고 '취업도 해야하는데 공부해야할 양이 너무 많아서, 어디까지 해야할지 몰라서' 라는 생각으로 두려움이 앞섰다. 
- 하지만, 이 책을 읽고나서 나는 하나의 규칙을 터득한것같다. 여러 약어로 날 두렵게 했던것들은 결국 소프트웨어를 계층으로 분리하고 **의존성 규칙**을 준수해 쉽게 프로그램을 변경할 수 있도록 하고자 만들어진거라고 생각하니 다 비슷해보이며, 두려움은 사라졌다. 
#### 왜 나의 앱에 아키텍처를 도입해야 하는가
- 설계가 우선일까 아키텍처가 우선일까
	- 설계란, 저수준의 구조 또는 결정사항 등을 의미할때가 많다.
		- *즉, 설계를 아파트 건축에 비교한다면 '아파트를 건축할 때 내부 인테리어는 어떻게할것인가','승강기 업체는 어떤 업체로 할 것인가', '부대시설은 어떤 시설을 선정할 것인가' 와 비슷한 것이라고 이해 했다.* 
	- 아키텍처란, 저수준의 세부사항과는 분리된 고수준의 무언가를 가리킬때 흔히 사용된다.
		- *아키텍처는 아파트 건축에 있어서, '콘크리트 타설 방식은 어떻게 할것인가', '방 구조를 어떻게 할것인가', '배선은 어떻게 배치할것인가'와 비슷한 것이라고 이해 했다.*
	- 고수준의 아키텍처를 전혀 생각하지 않고 설계만 한다면 (혼자 또는 2-3명) 크게 문제되지는 않겠지만 앱의 사이즈가 커지게 된다면 문제가 발생한다. 새로운 기능이 추가될때 기존의 코드를 수정하게 되는 가능성이 높아지며, 그런 수정으로 인해 여러 오류를 발생할 수 있으며 결국 앱을 다시 만들어야 하는 상황까지 올 수 있다. 
- 소프트웨어가 가진 본연의 목적을 추구하려면 소프트웨어는 반드시 부드러워야 한다. 다시 말해 변경하기 쉬어야 한다. 
	- 이해관계자가 기능에 대한 생각을 바꾸면, 이러한 변경사항을 간단하고 쉽게 적용할 수 있어야 한다. 
	- 즉, 이해관계자가 무리한 기능을 요구한다고 생각이 들고 이를 바꾸는게 불가능하다고 생각이 든다면, 그건 내가 코드의 설계를 못한거라고 생각해야 한다.
- 결국 아키텍처가 후순위가 되면 시스템을 개발하는 비용이 더 많이 들고, 일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 불가능해진다. 
- 그러므로, 빨리 가는 유일한 방법은 제대로 가는 것이다.
#### 그래서 아키텍처란?
- 소프트웨어는 두 종류의 가치, 즉 행위적 가치와 구조적 가치를 지닌다. 이 중에서 두 번째 가치가 더 중요한데, 소프트웨어를 부드럽게 만드는 것은 바로 이 구조적 가치이기 때문이다. 
	- *소프트웨어를 만든 이유는 기계의 행위를 빠르고 쉽게 변경하는 방법이 필요했기 때문이다.*
	- 유연성은 시스템의 형태, 컴포넌트의 배치 방색, 컴포넌트가 상호 연결되는 방식에 상당히 크게 의존한다. 
	- 소프트웨어를 부드럽게 유지하는 방법은 선택사항을 가능한 한 많이, 그리고 가능한 한 오랫동안 열어 두는 것이다. 그렇다면 열어 둬야 할 선택사항이란 무엇일까? 그것은 *바로 중요치 않은 세부사항*이다.
	- 소프트웨어 시스템은 주요한 두 가지 구성요소로 분해할 수 있다. 바로 *정책과 세부사항*이다.
		- 정책: 정책 요소는 모든 업무 규칙과 업무 절차를 구체화한다. 징책이란 시스템의 진정한 가치가 살아 있는 곳이다. 
		- 세부사항: 사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소지만, 정책이 가진 행위에는 조금도 영향을 미치지 않는다. 이러한 세부사항에는 입출력 장치, 데이터베이스, 서버, 프레임워크, 통신 프로토콜 등이 있다. 
	- **아키텍처의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는 데 있다.** 
		- 간단하게 보자면, 오늘날의 운영체제에서도 정책에 정책에 무관한 세부사항 사례를 확인할 수 있다. 바로 입출력 시스템이다. 아주 예전 소프트웨어는 천공기와 자기 테이프 등 서로 다른 입출력에 대해서 호환이 불가능 했으며, 이들 프로그램을 다시 작성해야 했다. 
		- 하지만 오늘날의 운영체제는 입출력 장치를 소프트웨어 함수로 추상화 했고, 해당 함수는 천공카드와 같은 단위 레코드를 처리한다. 
		- 프로그램은 운영체제의 서비스를 호출하고, 해당 서비스가 추상화된 단위 레코드 장치를 처리한다. 
		- 이렇게 되면 동일한 프로그램으로 어떠한 입출력이든 활용할 수 있다. **개방 폐쇄 원칙이 탄생한 순간이다.**
		- 이러한 방식을 원활히 활용할 수 있게 하는것이 아키텍처라고 생각한다.
- 좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 엄격하게 분리한다. 
- 이를 통해 정책은 세부사항에 관한 어떠한 지식도 갖지 못하게 되며, 어떤 경우에도 세부사항에 의존하지 않게 된다. 
- 좋은 아키텍트는 세부사항에 대한 결정을 가능한 한 오랫동안 미룰 수 있는 방향으로 정책을 설계한다.
#### 좋은 아키텍처?
- 좋은 아키텍처는 다음을 지원해야 한다. 
	1. **시스템의 유스케이스** 
		- 좋은 아키텍처가 행위를 지원하기 위해 할 수 있는 일 중에서 가장 중요한 사항은 행위를 명확히 하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것이다. 
	2. **시스템의 운영** 
		- 만약 시스템이 단일체로 작성되어 모노리틱 구조(Monolithic Architecture: 전통적인 웹 시스템 개발 스타일로, 하나의 애플리케이션 내에 모든 로직들이 들어가있는 "통짜 구조")를 갖는다면, 다중 프로세스, 다중 스레드, 또는 마이크로서비스 형태가 필요해질 때 개선하기가 어렵다. 
		- 그에 비해 아키텍처에서 각 컴포넌트를 적절히 격리하여 유지하고 컴포넌트 간 통신 방식을 특정 형태로 제현하지 않는다면, 시간이 지나 운영에 대한 필요한 요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬워질 것이다 .
	3. **시스템의 개발** 
		- 콘웨이의 법칙을 적용한다.
			- *시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.(소프트웨어의 구조는 그 소프트웨어를 만드는 조직의 구조와 일치한다.)*
		- 즉, 각 팀이 독립적으로 행동하기 편한 아키텍처를 반드시 확보하여 개발하는 동안 팀들이 서로를 방해하지 않도록 해야 한다. 
		- 이러한 아키텍처를 만들려면 잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할 할 수 있어야 한다.
	4. **시스템의 배포**
		- 좋은 아키텍처는 수십 개의 작은 설정 스크립트나 속성 파일을 약간씩 수정하는 방식을 사용하지 않는다. 
		- 좋은 아키텍처는 꼭 필요한 디렉터리나 파일을 수작업으로 생성하게 내버려 두지 않는다. 
		- 좋은 아키텍처라면 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다. 
- 말은 쉽다. 하지만 현실에서는 이러한 균형을 잡기가 매우 어렵다. 대부분의 경우 우리는 모든 유스케이스를 알 수 없으며, 운영하는 데 따르는 제약사항, 팀 구조, 배포 요구사항을 알 수 없으며, 운영하는 데 따르는 제약사항, 팀 구조, 배포 요구사항도 알지 못하기 때문이다. 
- 더 심각한 문제는 시스템의 생명주기의 단계를 하나씩 거쳐감에 따라 이 사항들도 반드시 변해간다는 사실이다. 
	- **결국, 좋은 아키텍처는 선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 해야 한다.**
- 그래서 소프트웨어 아키텍처는 선을 긋는 기술이며, 이러한 선을 **경계**라고 부른다. 경계는 소프트웨어 요소를 서로 분리하고, 경계 한편에 있는 요소가 반대편에 있는 요소를 알지 못하도록 막는다. 이들 선 중 일부는 프로젝트 수명 중 아주 초기에, 심지어 코드가 전혀 작성되기도 전에 그어지며, 어떤 선은 매우 나중에 그어진다. 
- 초기에 그어지는 선들은 가능한 한 오랫동안 결정을 연기시키기 위해, 그래서 이들 결정이 핵심적인 업무 로직을 오염시키지 못하게 만들려는 목적으로 쓰인다.
#### 어떻게 선을 그을까? 그리고 언제 그을까? 
- 소프트웨어 아키텍처에서 경계선을 그리려면 먼저 시스템을 컴포넌트 단위로 분할해야 한다. 일부 컴포넌트는 핵심 업무 규칙에 해당한다. 나머지 컴포넌트는 플로그인으로, 핵심 업무와는 직접적인 관련이 없지만 필수 기능을 포함한다. 
- 그런 다음 컴포넌트 사이의 화살표가 특정 방향, 즉 핵심 업무를 향하도록 이들 컴포넌트의 소스를 배치한다. 
- 이는 의존성 역전 원칙과 안정된 추상화 원칙을 응용한 것임을 확인할 수 있다. 
	- 의존성 화살표는 저수준 세부사항에서 고수준의 추상화를 향하도록 배치한다. 
![|600](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc7glxd%2FbtqCcBC3Kof%2F8MFgKTKBlCjFsk3W8tmkGK%2Fimg.png)
	- Business Rules 컴포넌트안에 DataBase Interface를 Database 컴포넌트안에 Database Access가 의존하고 있다.
	- Business Rule 컴포넌트에게 있어 Database 컴포넌트는 문제되지가 않는다. 그러나, Business Rules 컴포넌트의 호출을 쿼리언어로 변환하는 코드를 Database 컴포넌트가 담고있기 때문에 Database 컴포넌트 Business Rules 컴포넌트 없이 존재할 수 없다. 
	- Database Access에서 출발하는 두 화살표를 주목하면, 이들 두 화살표는 Database Access 클래스로부터 바깥쪽으로 향한다. 즉, 이 도표에서 Database Access가 존재한다는 사실을 알고 있는 클래스는 없다는 뜻이다. 
#### 경계 횡단하기 
- '런타임에 경계를 횡단한다' 함은 그저 경계 한쪽에 있는 기능에서 반대편 기능을 호출하여 데이터를 전달하는 일에 불과하다. 적절한 위치에서 경계를 횡단하게 하는 비결은 소스 코드 의존성 관리에 있다. 
- 아키텍처 경계 중에서 가장 단순하며 가장 흔한 형태는 물리적으로 엄격하게 구분되지 않는 형태이다. 이 형태에서는 함수와 데이터가 단일 프로세서에서 같은 주소 공간을 공유하며 그저 나름의 규칙에 따라 분리되어 있을 뿐이다. 
	- 즉, 아키텍트는 결합도는 적절히 분리하기 위해 함수를 가리키는 포인터라는 위험한 옛 관행을 기대야 했고, 컴포넌트를 분리하려는 어떤 종류의 시도도 결국 포기했을 것이다. 
- 그렇기에 아키텍처는 거의 모든 경우에 특정한 동적 다향성에 의존하여 내부 의존성을 관리한다. 바로 이 때문에 최근 수십 년 동안 객체 지향 개발이 아주 중요한 패러다임이 될 수 있었다. 
#### 정책과 수준 
- 소프트웨어 아키텍처를 개발하려는 기술에는 정책을 신중하게 분리하고, 정책이 변경되는 양상에 따라 정책을 재편성하는 일도 포함된다. 동일하 이유로 시점에 변경되는 정책은 동일한 수준에 위치하며, 동일한 컴포넌트에 속해야 한다. 서로 다른 이유로, 혹은 다른 시점에 변경되는 정책은 다른 수준에 위치하며, 반드시 다른 컴포넌트로 분래햐아 한다. 
- *좋은 아키텍처라면 각 컴포넌트를 연결할 때 의존성의 방향이 컴포넌트의 수준을 기반으로 연결되도록 만들어야 한다. 즉, 저수준 컴포넌트가 고수준 컴포넌트에 의존하도록 설계해야 한다.*
![|500](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FwSaQu%2FbtqCcV2ppR6%2FO2RfHMVn6sZi9nDGIldDv0%2Fimg.png)
- 번역 컴포넌트는 이 시스템에서 최고 수준 컴포넌트인데, 입력과 출력에서 부터 가장 멀리 떨어져 있기 때문이다. 
	- 주목할 점은 데이터 흐름과 소스 코드 의존성이 항상 같은 방향을 가리키지는 않는다는 사실이다. 
	- **소스 코드 의존성은 그 수준에 따라 결합되어야 하며, 데이터 흐름을 기준으로 결합되어서는 안 된다.**
	- 자칫하면 잘못된 아키텍처가 만들어지는데, 예를 들어 암호화 프로그램을 다음처럼 작성하면 그렇게 된다. 
``` java
function encrypt() { 
	while(true)
	writeChar(translate(readChar())); 
}
```
- 이는 잘못된 아키텍처이다. 고수준인 encrypt 함수가 저수준인 readChar와 writeChart 함수에 의존하기 때문이다. 
![|500](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb5pQIJ%2FbtqCagtkyT1%2FCJtjtj3c2kji3KlxPc9CA1%2Fimg.png)
- 이 수준에서 고수준의 암호화 정책을 저수준의 입력/출력 정책으로부터 분리시킨 방식에 주목할 필요가 있다. 
- 이 방식 덕분에 이 암호화 정책을 더 넓은 맥락에서 사용할 수 있다. 
#### 업무 규칙 
- 핵심 업무 규칙은 보통 데이터를 요구한다. 예를 들어 대출에는 대출 잔액, 이자율, 지급 일정이 필요하다. 
- 우리는 이러한 데이터를 핵심 업무 데이터라고 부를수 있다. 심지어 이러한 데이터는 시스템으로 자동화되지 않은 경우에도 존재하는 그런 데이터이다. 
- 핵심 규칙과 핵심 데이터는 본질적으로 결합되어 있기 때문에 객체로 만들 좋은 후보가 된다. 
- 이러한 유형의 객체를 **엔티티(Entity)** 라고 한다.
- 모든 업무 규칙이 엔티티처럼 순수한 것은 아니다. 
	- 예를 들어 은행 직원이 신규 대출을 생성할 때 사용하는 애플리케이션을 상상해 보자. 은행에서 대출 담당자가 신청자의 신상정보를 수집하여 검증한 후, 신청자의 신용도가 500보다 낮다면 대출 견적을 제공하지 않기로 결졍했다고 해 보자. 따라서 시스템에서 신상정보 화면을 모두 채우고 검증한 후, 신용도가 하한선보다 높은지가 확인된 이후에 대출 견적 화면으로 진행되어야 한다는 식으로 은행에서 업무 요건을 기술했다고 해 보자. 
- 바로 이것이 유스케이스이다. **유스케이스**는 자동화된 시스템이 사용되는 방법을 설명한다. 
- *즉, 엔티티가 어떻게 춤을 출지를 유스케이스가 제어한다는 것이다.* 
- 유스케이스는 객체이다. 유스케이스는 애플리케이션에 특화된 업무 규칙을 구현하는 하나 이상의 함수를 제공한다. 
- 또한 유스케이스는 입력 데이터, 출력 데이터, 유스케이스가 상호작용하는 엔티티에 대한 참조 데이터 등의 데이터 요소를 포함한다. 
- 엔티티는 자신을 제어하는 유스케이스에 대해 아무것도 알지 못한다. 이는 의존성 역전 원칙을 준수하는 의존성 방향에 대한 또 다른 예이다. 
- *엔티티와 같은 고수준 개념은 유스케이스와 같은 저수준 개념에 대해 아무것도 알지 못한다. 반대로 저수준인 유스케이스는 고수준인 엔티티에 대해 알 고 있다.* 
	- 왜 엔티티는 고수준이며, 유스케이스는 저수준일까? 
	- 유스케이스는 단일 애플리케이션에 특화되어 있으며, 따라서 해당 시스템의 입력과 출력에 보다 가깝게 위치하기 때문이다. 
	- 엔티티는 수많은 다양한 애플리케이션에서 사용될 수 있도록 일반화된 것이므로, 각 시스템의 입력이나 출력에서 더 멀리 떨어져 있다. 
- 결국, 업무 규칙은 사용자 인터페이스나 데이터베이스와 같은 저수준의 관심사로 인해 오염되어서는 안 되며, 원래 그대로의 모습으로 남아 있어야 한다. 
- 이상적으로는 업무 규칙을 표현하는 코드는 반드시 시스템의 심장부에 위치 해야 하며, 덜 중요한 코드는 이 심장부에 플러그인되어야 한다. 
- **업무 규칙은 시스템에서 가장 독립적이며 가장 많이 재사용할 수 있는 코드여야 한다.** 
#### 드디어..! 클린 아키텍처
- 여러 아키텍처 모델을의 세부적인 면에서는 다소 차이가 있더라도 그 내용은 상당히 비슷하다. 이들의 목표는 모두 같은데, 바로 **관심사의 분리(Separation of concerns)** 이다.
- 이들은 모두 소프트웨어를 계층으로 분리함으로써 관심사의 분리라는 목표를 달성할 수 있었다. 각 아키텍처는 최소한 업무 규칙을 위한 계층 하나와, 사용자와 시스템 인터페이스를 위한 또 다른 계층 하나를 반드시 포함한다. 
	- 프레임워크 독립성 
		- 아키텍처는 프레임워크의 존재 여부에 외존하지 않는다. 
	- 테스트 용이성 
		- 업무 규칙은 UI, 데이터베이스, 웹 서버, 또는 여타 외부 요소가 없이도 테스트할 수 있다. 
	- UI 독립성 
		- 시스템의 나머지 부분을 변경하지 않고도 UI를 쉽게 변경할 수 있다. 
	- 데이터베이스 독립성 
		- 업무 규칙은 데이터베이스에 결합되지 않는다.
	- 모든 외부 에이전시에 대한 독립성 
		- 업무 규칙은 외부 세계와의 인터페이스에 대해 전혀 알지 못한다. 
![|500](https://techblog.woowahan.com/wp-content/uploads/img/2019-10-02/the-clean-architecture.png)
- 보통 안으로 들어갈수록 고수준의 소프트웨어가 된다. 바깥쪽 원은 메커니즘이고, 안쪽 원은 정책이다. 
- **이러한 아키텍처가 동작하도록 하는 가장 중요한 규칙은 의존성 규칙이다.** 
	- 엔티티는 전사적인 핵심 업무 규칙을 캡슐화한다. 
	- 유스케이스는 애플리케이션에 특화된 업무 규칙을 포함한다. 또한 유스케이스 계층의 소프트웨어는 시스템의 모든 유스케이스를 캡슐화하고 구현한다. 
	- 인터페이스 어댑터계층은 일련의 어댑터들로 구성된다. 데이터를 유스케이스와 엔티티에게 가장 편리한 형식에서 데이터베이스나 웹 같은 외부 에이전시에게 가장 편리한 형식으로 변환한다. 
- 소프트웨어를 계층으로 분리하고 의존성 규칙을 준수한다면 본질적으로 테스트하기 쉬운 시스템을 만들게 될 것이며, 그에 따른 이점을 누릴 수 있다. 
- 결국, 빨리 가는 유일한 방법은 제대로 가는 것이다. 
### 출처(참고문헌) 
- Clean Architecture (로버트 C.마틴)
### 연결문서 
- 
### Tag
- #CS/Coding/Clean_Architecture